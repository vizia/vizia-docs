<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="In graphics code it’s very common to pass `width` and `height` along with a `Vec` of pixels, all as separate arguments. This is tedious, and can lead to errors."><title>vizia_core::vg::imgref - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-f3501f0f5ae15dfb.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="vizia_core" data-themes="" data-resource-suffix="" data-rustdoc-version="1.71.0 (8ede3aae2 2023-07-12)" data-search-js="search-4926e5fc22a5646a.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../../../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../../../crates.js"></script><script defer src="../../../static.files/main-f0540c1d82cde29b.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../vizia_core/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../../vizia_core/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate imgref</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.1.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li><li><a href="#types">Type Definitions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a href="../../index.html">vizia_core</a>::<wbr><a href="../index.html">vg</a>::<wbr><a class="mod" href="#">imgref</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>In graphics code it’s very common to pass <code>width</code> and <code>height</code> along with a <code>Vec</code> of pixels,
all as separate arguments. This is tedious, and can lead to errors.</p>
<p>This crate is a simple struct that adds dimensions to the underlying buffer. This makes it easier to correctly keep track
of the image size and allows passing images with just one function argument instead three or four.</p>
<p>Additionally, it has a concept of a <code>stride</code>, which allows defining sub-regions of images without copying,
as well as handling padding (e.g. buffers for video frames may require to be a multiple of 8, regardless of logical image size).</p>
<p>For convenience, there are iterators over rows or all pixels of a (sub)image and
pixel-based indexing directly with <code>img[(x,y)]</code> (where <code>x</code>/<code>y</code> can be <code>u32</code> as well as <code>usize</code>).</p>
<p><code>Img&lt;Container&gt;</code> type has aliases for common uses:</p>
<ul>
<li>Owned: <code>ImgVec&lt;T&gt;</code> → <code>Img&lt;Vec&lt;T&gt;&gt;</code>  (use it in <code>struct</code>s and return types)</li>
<li>Reference: <code>ImgRef&lt;T&gt;</code> → <code>Img&lt;&amp;[T]&gt;</code> (use it in function arguments)</li>
<li>Mutable reference: <code>ImgRefMut&lt;T&gt;</code> → <code>Img&lt;&amp;mut [T]&gt;</code></li>
</ul>
<p>It is assumed that the container is <a href="https://crates.io/crates/rgb/">one element per pixel</a>, e.g. <code>Vec&lt;RGBA&gt;</code>,
and <em>not</em> a <code>Vec&lt;u8&gt;</code> where 4 <code>u8</code> elements are interpreted as one pixel.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>imgref::<span class="kw-2">*</span>;

<span class="kw">fn </span>main() {
    <span class="kw">let </span>img = Img::new(<span class="macro">vec!</span>[<span class="number">0</span>; <span class="number">1000</span>], <span class="number">50</span>, <span class="number">20</span>); <span class="comment">// 1000 pixels of a 50×20 image

    </span><span class="kw">let </span>new_image = some_image_processing_function(img.as_ref()); <span class="comment">// Use imgvec.as_ref() instead of &amp;imgvec for better efficiency

    </span><span class="macro">println!</span>(<span class="string">&quot;New size is {}×{}&quot;</span>, new_image.width(), new_image.height());
    <span class="macro">println!</span>(<span class="string">&quot;And the top left pixel is {:?}&quot;</span>, new_image[(<span class="number">0u32</span>,<span class="number">0u32</span>)]);

    <span class="kw">let </span>first_row_slice = <span class="kw-2">&amp;</span>new_image[<span class="number">0</span>];

    <span class="kw">for </span>row <span class="kw">in </span>new_image.rows() {
        <span class="comment">// …
    </span>}
    <span class="kw">for </span>px <span class="kw">in </span>new_image.pixels() {
        <span class="comment">// …
    </span>}

    <span class="comment">// slice (x, y, width, height) by reference - no copy!
    </span><span class="kw">let </span>fragment = img.sub_image(<span class="number">5</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">15</span>);

    <span class="comment">//
    </span><span class="kw">let </span>(vec, width, height) = fragment.to_contiguous_buf();
}</code></pre></div>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Img.html" title="struct vizia_core::vg::imgref::Img">Img</a></div><div class="desc docblock-short">Basic struct used for both owned (alias <code>ImgVec</code>) and borrowed (alias <code>ImgRef</code>) image fragments.</div></li><li><div class="item-name"><a class="struct" href="struct.PixelsIter.html" title="struct vizia_core::vg::imgref::PixelsIter">PixelsIter</a></div><div class="desc docblock-short">Iterates over pixels in the (sub)image. Call <code>Img.pixels()</code> to create it.</div></li><li><div class="item-name"><a class="struct" href="struct.PixelsIterMut.html" title="struct vizia_core::vg::imgref::PixelsIterMut">PixelsIterMut</a></div><div class="desc docblock-short">Iterates over pixels in the (sub)image. Call <code>Img.pixels_mut()</code> to create it.</div></li><li><div class="item-name"><a class="struct" href="struct.PixelsRefIter.html" title="struct vizia_core::vg::imgref::PixelsRefIter">PixelsRefIter</a></div><div class="desc docblock-short">Iterates over pixels in the (sub)image. Call <code>Img.pixels_ref()</code> to create it.</div></li><li><div class="item-name"><a class="struct" href="struct.RowsIter.html" title="struct vizia_core::vg::imgref::RowsIter">RowsIter</a></div><div class="desc docblock-short">Rows of the image. Call <code>Img.rows()</code> to create it.</div></li><li><div class="item-name"><a class="struct" href="struct.RowsIterMut.html" title="struct vizia_core::vg::imgref::RowsIterMut">RowsIterMut</a></div><div class="desc docblock-short">Rows of the image. Call <code>Img.rows_mut()</code> to create it.</div></li></ul><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.ImgExt.html" title="trait vizia_core::vg::imgref::ImgExt">ImgExt</a></div><div class="desc docblock-short">Additional methods that depend on buffer size</div></li><li><div class="item-name"><a class="trait" href="trait.ImgExtMut.html" title="trait vizia_core::vg::imgref::ImgExtMut">ImgExtMut</a></div><div class="desc docblock-short">Additional methods that depend on buffer size</div></li></ul><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.ImgRef.html" title="type vizia_core::vg::imgref::ImgRef">ImgRef</a></div><div class="desc docblock-short">Reference to pixels inside another image.
Pass this structure by value (i.e. <code>ImgRef</code>, not <code>&amp;ImgRef</code>).</div></li><li><div class="item-name"><a class="type" href="type.ImgRefMut.html" title="type vizia_core::vg::imgref::ImgRefMut">ImgRefMut</a></div><div class="desc docblock-short">Same as <code>ImgRef</code>, but mutable
Pass this structure by value (i.e. <code>ImgRef</code>, not <code>&amp;ImgRef</code>).</div></li><li><div class="item-name"><a class="type" href="type.ImgVec.html" title="type vizia_core::vg::imgref::ImgVec">ImgVec</a></div><div class="desc docblock-short">Image owning its pixels.</div></li></ul></section></div></main></body></html>